#lang racket
(define (build-mat m n f)
  (build-list m (λ (x) (build-list n (λ (y) (f x y))))))

(define (main n f)
  (define (proc i j)
  (define (help i j s n)
    (cond ((= i (- n 1)) (+ s (* 2 (- n 1)) (- n j)))
          ((= i 0) (+ s j))
          ((= j (- n 1)) (+ s n i))
          ((= j 0) (- (+ s (* 4 n)) i 3))
          (else (help (- i 1) (- j 1) (+ s (* 4 (- n 1))) (- n 2)))))
  (help i j 0 n))
  (define out (open-output-file f) #:exists 'replace)
  (define mat (build-mat n n proc))
  (for-each (λ (line) (for-each (λ (num) (write num out) (write #\space out)) line) (write #\newline out)) mat)
  (close-output-port out))

;узнать по числу где стоит в матрице (выдать пару - строка столбец) или #f
;RLE - сжатие по длине abcxxxxaaabcad <- 2abc130x129a3abcd - 128->2 129->3 - из файла

(define (P1 n)
  (define x (read-char in))
  (display (make-string n x) out))

(define (P2 n)
  (display (read-char in) out)
  (cond ((> n 1) (P2 (- n 1)))))

(define (P3 f1 f2)
  (define in (open-input-file f1))
  (define in (open-input-file f2))
  (define (iter))
  (define x (read-char in))
  (if (equal? x eof)
      (close-output-port out)
      (if (< (char->integer x) 128)
          (P2 (+ (char->integer x) 1))
          (P1 (- (char->integer x) 126))
          (iter)))
  (iter))

(define (code f1 f2)
  (define in (open-input-file f1))
  (define in (open-output-file f2) #:exists 'replace)
  (define x (read-char in))
  (define (s1 n char)
    (if (equal? x eof) (begin (write (integer->char (+ n 126)) out) (write char out) (close-output-port out))
      (if (equal? char x)
          (s1 (+ n 1) char)
          (begin (write (integer->char (+ n 126)) out) (write char out) (close-output-port out) (s2 0 (list x))))))
  (define (s2 n lst)
    (define x (read-char in))
    (if (or (equal? x eof) (equal? x (car lst)))
        (begin (write (integer->char (- n 1)) out) (display (list->string (reverse (cdr lst))) out) (s1 2 x))
        (if (equal? x eof) (begin (display (integer->char n) out) (display (list->string (reverse lst) out)) (close-output-port out))
            (s2 (+ n 1) (cons x lst))))))

;(define (member-symbol? str)
 ; (define lst (string-split str))
  ;  (define y (length lst))
  ;(define (help lst1 lst2 lst3 lst4 x)
    ;(if (empty? lst2) #f 
     ;   (if (= (same lst2 lst3) 1) (car lst2) #f) 
      ;  (if (= (member? (car lst2) lst3) 1) 
       ;     (if (empty? lst4) (if (= (+ x 1) y) (string (car lst2))
        ;(if (empty? lst2) #f
         ;   (help lst1 (cdr lst2) (string->list (car lst1)) (cdr lst1) 1)))
          ;                            (help lst1 lst2 (string->list (car lst4)) (cdr lst4) (+ x 1))))
        ;(help lst1 (cdr lst2) (string->list (car lst1)) (cdr lst1) 1)))
  ;(cond 
   ;((= y 0) "")
   ;((= y 1) (substring (car lst) 0 1))
  ; ((= y 2) (for2case (string->list (car lst)) (string->list (cadr lst)) (string->list (cadr lst))))
   ;((= y 3)
     ;             (help '() (string->list (car lst)) (string->list (cdr lst)) (string->list (cadr lst) 1)))
    ;              (else (help (cdr lst) (string->list (car lst)) (string->list (cadr lst)) (caddr lst) 1))))

;(= 2 (length (string-split str)))